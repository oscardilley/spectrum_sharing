""" channel_simulator.py

Runs link simulators given channel responses using Sionna.

"""

import tensorflow as tf
import numpy as np
from sionna.channel import cir_to_ofdm_channel, subcarrier_frequencies, ApplyOFDMChannel #, CIRDataset, OFDMChannel
from sionna.nr import PUSCHConfig, PUSCHTransmitter, PUSCHReceiver
from sionna.utils import compute_bler, compute_ber, ebnodb2no

class ChannelSimulator(tf.keras.Model):
    """ Simulate multi-user PUSCH/PDSCH transmissions over channels generated by ray
    tracing.

    This is achieved by frequency domain OFDM BER simulations.

    A key assumption is that the mobile can connect to multiple basestations simulataneously.

    Parameters
    ----------
    num_tx: int
        Number of transmitters in the scene.

    num_rx: int
        Number of receivers in the scene.
    
    a: [batch_size, num_rx, num_rx_ant, num_tx, num_tx_ant, max_num_paths, num_time_steps], tf.complex
        Path coefficients.
    
    tau: [batch_size, num_rx, num_tx, max_num_paths], tf.float
        Path delays.

    sinr: [num_rx, num_tx] flattened, tf.float
        The SINR values at the receiver locations corresponding to each transmitter.

    subcarrier_spacing: int
        How the bandwidth is divided into OFDM subcarriers. Must match that used to generated the CIR.

    fft_size: int
        Size of the FFT. Must match that used to generated the CIR.

    Inputs
    ------
    block_size: int
        Number of simulataneously simulated slots

    batches: int
        The number of blocks to simulate.

    ebno_db: float
        Signal to noise ratio used to calculate the noise variance

    Output
    ------
    ber: [num_rx, 1], tf.float64
        The bit error rate performance from each receiver listening to both transmitters. Multi-link operation.

    """
    def __init__(self, num_tx, num_rx, subcarrier_spacing, fft_size):
        super().__init__()

        # Instantiating key attributes
        self.frequencies = subcarrier_frequencies(fft_size, subcarrier_spacing)
        self.num_tx = num_tx
        self.num_rx = num_rx

        # Initialising the PUSCH components (there is PUSCH and PDSCH symmetry):
        self.pusch_config = PUSCHConfig() # Init pusch_transmitter with default settings 
        self.pusch_config.carrier.n_size_grid = int(fft_size / 12) # 12 subcarriers in a RB in 5G NR
        self.pusch_config.carrier.subcarrier_spacing = int(subcarrier_spacing / 1000)
        self.channel = ApplyOFDMChannel(add_awgn=True)

        # Channels between each transmitter and receiver
        self.h_freq = None

        # Processing the SINR
        self.sinr = None
        self.sinr_no = None

    def update_channel(self, num_active_tx, a, tau):
        # Call when changing simulation channel without creating new instance - performance benefits with jit compilation.
        self.num_tx = num_active_tx
        self.h_freq = cir_to_ofdm_channel(self.frequencies, a, tau, normalize=True) # [batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_steps, fft_size

    def update_sinr(self, sinr):
        # Call when changing simulation channel without creating new instance - performance benefits with jit compilation.
        self.pusch_transmitter = PUSCHTransmitter(self.pusch_config) # re-initialise to get new target_coderate and num_bits_per_symbol when MCS changing
        self.pusch_receiver = PUSCHReceiver(self.pusch_transmitter, channel_estimator="perfect")
        M = float(self.pusch_config.tb.num_bits_per_symbol)
        R = float(self.pusch_config.tb.target_coderate)
        ebno = sinr - (10 * np.log10(R * M)) # SINR to EbNo conversion
        self.sinr = sinr
        def ebno_to_no(x):
            return ebnodb2no(
                x,
                self.pusch_transmitter._num_bits_per_symbol,
                self.pusch_transmitter._target_coderate,
                self.pusch_transmitter.resource_grid,
            )

        self.sinr_no = tf.map_fn(ebno_to_no, ebno) # Apply element-wise using tf.map_fn
        self.sinr_no = tf.clip_by_value(self.sinr_no, 0.0, 1000.0) # Clip output to [0, 1000]

        
    @tf.function(jit_compile=True, reduce_retracing=True)
    def iterate(self, ins):
        h, noise = ins
        h = tf.repeat(h, repeats=self.x.shape[0], axis=0)
        y = self.channel([self.x, h, noise])
        b_hat = self.pusch_receiver([y, h, noise]) # for perfect channel estimation
        # b_hat = self.pusch_receiver([y, noise])

        # CHECK HOW NON PERFECT ESTIMATION PERFORMS

        return compute_bler(self.b, b_hat), compute_ber(self.b, b_hat)


    # Do not use @tf.function as attributes will not update
    def call(self, batch_size):
        self.x, self.b = self.pusch_transmitter(batch_size) # create a different set of bits for batch element

        # Note that in antenna elements, Sionna treats polarisations are separate ports
        per_link_h = []
        for i in range(self.num_rx):
            for j in range(self.num_tx):
                h_ij = self.h_freq[:,i:i+1,:,j:j+1,:,:,:]  # [batch, 1, rx_ant, 1, tx_ant, time, fft]
                h_ij = tf.reduce_sum(h_ij, axis=2, keepdims=True)   # RX collapsing to SISO [batch, 1, 1, 1, tx_ant, time, fft]
                h_ij = tf.reduce_sum(h_ij, axis=4, keepdims=True)  # TX [batch, 1, 1, 1, 1, time, fft]
                per_link_h.append(h_ij)

        h_freq_links = tf.stack(per_link_h, axis=0) 
        noise = tf.reshape(self.sinr_no, ([-1])) # flatten
        bler_per_link, ber_per_link = tf.map_fn(self.iterate, elems=(h_freq_links, noise), fn_output_signature=(tf.float64, tf.float64)) # repeated for each link

        return tf.reshape(bler_per_link, (self.num_tx, self.num_rx)), tf.reshape(self.sinr, (self.num_tx, self.num_rx))


# class ChannelSimulator(tf.keras.Model):
#     """ Simulate multi-user PUSCH/PDSCH transmissions over channels generated by ray
#     tracing.

#     This is achieved by frequency domain OFDM BER simulations.

#     A key assumption is that the mobile can connect to multiple basestations simulataneously.

#     Parameters
#     ----------
#     num_tx: int
#         Number of transmitters in the scene.

#     num_rx: int
#         Number of receivers in the scene.
    
#     a: [batch_size, num_rx, num_rx_ant, num_tx, num_tx_ant, max_num_paths, num_time_steps], tf.complex
#         Path coefficients.
    
#     tau: [batch_size, num_rx, num_tx, max_num_paths], tf.float
#         Path delays.

#     sinr: [num_rx, num_tx] flattened, tf.float
#         The SINR values at the receiver locations corresponding to each transmitter.

#     subcarrier_spacing: int
#         How the bandwidth is divided into OFDM subcarriers. Must match that used to generated the CIR.

#     fft_size: int
#         Size of the FFT. Must match that used to generated the CIR.

#     Inputs
#     ------
#     block_size: int
#         Number of simulataneously simulated slots

#     batches: int
#         The number of blocks to simulate.

#     ebno_db: float
#         Signal to noise ratio used to calculate the noise variance

#     Output
#     ------
#     ber: [num_rx, 1], tf.float64
#         The bit error rate performance from each receiver listening to both transmitters. Multi-link operation.

#     """
#     def __init__(self, num_tx, num_rx, subcarrier_spacing, fft_size):
#         super().__init__()

#         # Instantiating key attributes
#         self.frequencies = subcarrier_frequencies(fft_size, subcarrier_spacing)
#         self.num_tx = num_tx
#         self.num_rx = num_rx

#         # Initialising the PUSCH components (there is PUSCH and PDSCH symmetry):
#         self.pusch_config = PUSCHConfig(subcarrier_spacing = subcarrier_spacing / 1000) # Init pusch_transmitter with default settings 
#         self.pusch_config.carrier.n_size_grid = int(fft_size / 12) # 12 subcarriers in a RB in 5G NR
#         self.channel = ApplyOFDMChannel(add_awgn=True)
#         #self.pusch_config.show() 
#         self.pusch_transmitter = PUSCHTransmitter(self.pusch_config) 
#         self.pusch_receiver = PUSCHReceiver(self.pusch_transmitter) 

#         # Channels between each transmitter and receiver
#         self.h_freq = None

#         # Processing the SINR
#         self.sinr = None
#         self.sinr_no = None

#     def update_channel(self, num_active_tx, a, tau):
#         # Call when changing simulation channel without creating new instance - performance benefits with jit compilation.
#         self.num_tx = num_active_tx
#         self.h_freq = tf.stack([cir_to_ofdm_channel(self.frequencies, a[:,i:i+1,:,j:j+1,:,:,:], tau[:,i:i+1,j:j+1,:], normalize=False) for j in range(self.num_tx) for i in range(self.num_rx)], axis=0)
#         # self.h_freq = tf.reduce_sum(self.h_freq, axis=2, keepdims=True)   # RX collapsing to SISO [batch, 1, 1, 1, tx_ant, time, fft]
#         # self.h_freq = tf.reduce_sum(self.h_freq, axis=4, keepdims=True)  # TX [batch, 1, 1, 1, 1, time, fft] # TRY THIS 



#     def update_sinr(self, sinr):
#         # Call when changing simulation channel without creating new instance - performance benefits with jit compilation.
#         M = np.array(self.pusch_config.tb.num_bits_per_symbol)
#         R = np.array(self.pusch_config.tb.target_coderate)
#         ebno = sinr - (10 * np.log10(R * M)) # SINR to EbNo conversion
#         self.sinr = sinr
#         self.sinr_no = tf.clip_by_value(tf.convert_to_tensor([ebnodb2no(item,
#             self.pusch_transmitter._num_bits_per_symbol, 
#             self.pusch_transmitter._target_coderate, 
#             self.pusch_transmitter.resource_grid) for item in ebno]), 0, 100)
        

#     # @tf.function(jit_compile=True, reduce_retracing=True)
#     def iterate(self, ins):
#         h, noise = ins
#         y = self.channel([self.x, h, noise]) # noise is due to the physical channel effects and noise
#         b_hat = self.pusch_receiver([y, noise]) # noise if used for decoding
#         bler = compute_bler(self.b, b_hat)
#         ber = compute_ber(self.b, b_hat)


#         tf.print("h shape:", tf.shape(h))
#         tf.print("y shape:", tf.shape(y))
#         tf.print("b_hat shape:", tf.shape(b_hat))
#         tf.print("b shape:", tf.shape(self.b))
#         tf.print("Noise shape:", tf.shape(noise))
#         tf.print("x shape:", tf.shape(self.x))

#         return bler, ber

#     # Do not use @tf.function as attributes will not update
#     def call(self, batch_size):
#         self.x, self.b = self.pusch_transmitter(batch_size)  
#         bler_per_link, ber_per_link = tf.map_fn(self.iterate, elems=(self.h_freq, self.sinr_no), fn_output_signature=(tf.float64, tf.float64))

#         print("BLER:", tf.reshape(bler_per_link, (self.num_tx, self.num_rx)))
#         print("BER:", tf.reshape(ber_per_link, (self.num_tx, self.num_rx)))
#         print("SINR:", tf.reshape(self.sinr, (self.num_tx, self.num_rx)))
 
#         return tf.reshape(bler_per_link, (self.num_tx, self.num_rx)), tf.reshape(self.sinr, (self.num_tx, self.num_rx))
